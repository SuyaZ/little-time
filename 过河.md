
[P1052 [NOIP2005 提高组] 过河 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1052)

# `[NOIP2005 提高组] 过河`

## 题目描述

在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：$0,1,\cdots,L$（其中 $L$ 是桥的长度）。坐标为 $0$ 的点表示桥的起点，坐标为 $L$ 的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是 $S$ 到 $T$ 之间的任意正整数（包括 $S,T$）。当青蛙跳到或跳过坐标为 $L$ 的点时，就算青蛙已经跳出了独木桥。

题目给出独木桥的长度 $L$，青蛙跳跃的距离范围 $S,T$，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。

## 输入格式

输入共三行，

- 第一行有 $1$ 个正整数 $L$，表示独木桥的长度。
- 第二行有 $3$ 个正整数 $S,T,M$，分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数。
- 第三行有 $M$ 个不同的正整数分别表示这 $M$ 个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。

## 输出格式

一个整数，表示青蛙过河最少需要踩到的石子数。

## 样例 #1

### 样例输入 #1

```
10
2 3 5
2 3 5 6 7
```

### 样例输出 #1

```
2
```

## 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$1\le L \le 10^4$；
- 对于 $100\%$ 的数据，$1\le L \le 10^9$，$1\le S\le T\le10$，$1\le M\le100$。

**【题目来源】**

NOIP 2005 提高组第二题


## 题解

#dp  #动态规划 #离散化 #数学模型 

首先这道题目的的意思是，青蛙不一定要踩着石头，我最开始以为是贪心决策，每一次跳跃都尽量踩着最远的石头，结果完美 WA .
以下是最初的贪心决策的代码，很显然是错的：
```cpp
#include<iostream>

using namespace std;
const int N = 110;

int rock[N];
int S, T, M, L;

int main()
{
    cin>>L;
    cin>>S>>T>>M;
    for(int i=1; i<=M; i++)
    {
        scanf("%d", &rock[i]);
    }
    
    int start = 0;
    int num = 0;
    for(int i=1; i<=M; )
    {
        while(rock[i] - start <= T && i <= M) i++;
        
        if(i > M && rock[i] - start >= S)
        {
            num ++;
            break;
        }
        
        if(rock[i] - start > T)
        {
            start = rock[i-1];
            num++;
        }
        
        if(start >= L) break;
    }
    
    cout<<num;
    
    return 0;
}
```

既然每一个状态都会受到之前的状态的影响，那么很显然采用动态规划求解，那么状态转移方程组如何求解？

首先，设`dp[i]` 表示：跳到 `x=i` 的点上，最少需要踩过的石头数目。
则在前面`(i-s)` 到`(i-t)` 的点都可以改变`i` 点的值 ,
因此我们可以取 `f[i-s]-f[i-t]` 之中的最小值 ， 假设为 `dp[i-j]` 。

如果`x = i-j` 处有石头，则加上 1 ，这里直接使用 `flag[i-j] = 1` 表示该点处有石头（有为 1，没有则为 0 ）。

但是令人苦恼的是，这里的数据范围 `L<=1e9`，显然直接开 flag 数组的话会爆空间。但是石头的数目却非常少，这样稀疏的模型，可以采用离散化来求解。


